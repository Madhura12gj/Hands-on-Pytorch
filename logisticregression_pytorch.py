# -*- coding: utf-8 -*-
"""LogisticRegression_Pytorch

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T46TD-TvDTf7mkzo5i8hzs2zHYLNph8y
"""

#importing the libraries
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable

"""A logistic regression model is a predictive analysis model. This model is used when the predicting variable is binary. i.e., y_pred has a value either 0 or 1 ."""

#creating linear tensors having data points
x_data=Variable(torch.Tensor([[10.0],[9.0],[3.0],[4.0]]))
y_data=Variable(torch.Tensor([[1.0],[2.0],[3.0],[4.0]]))

"""Application of a Sigmoid function will help to identify the class of the predicted output as 0 or 1. Any output grater than 0.5 will be classified as 1 else 0."""

class LogisticRegression(torch.nn.Module):
  def __init__(self):
    super(LogisticRegression, self).__init__()
    self.Linear = torch.nn.Linear(1,1)

  def forward(self,x):
    y_pred = torch.sigmoid(self.Linear(x))
    return y_pred
  
model= LogisticRegression()

"""Next step is to predict the loss. For Logistic regression model we use Binary Cross Entropy also known as Binary Logarithmic loss function .This is commonly used for Logistic regression tasks for predicting a binary output."""

criterion=torch.nn.BCELoss(size_average=True)

optimizer=torch.optim.SGD(model.parameters(),lr=0.01)

for epoch in range(20):
  model.train()
  optimizer.zero_grad()

  #forward pass
  y_pred = model(x_data)

  #calculate loss
  loss= criterion(y_pred,y_data)

  #backward pass
  loss.backward()
  optimizer.step()

print(y_pred)

new_X = Variable(torch.Tensor([[4.0]]))
y_pred = model(new_X)
print("predicted Y value: ", y_pred.data[0][0])